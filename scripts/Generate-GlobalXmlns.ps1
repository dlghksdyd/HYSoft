# scripts/Generate-GlobalXmlns.ps1
[CmdletBinding()]
param(
  [Parameter(Mandatory=$true)][string]$Url,
  [Parameter(Mandatory=$true)][string]$Prefix,
  # 문자열로 받고 직접 파싱 (true/false/1/0/yes/no)
  [Parameter(Mandatory=$true)][string]$IncludeAll,
  [Parameter()][string]$Exclude,
  # 한 줄당 하나의 파일 전체 경로
  [Parameter(Mandatory=$true)][string]$FilesList,
  [Parameter(Mandatory=$true)][string]$OutputFile
)

# 문자열 → bool
$IncludeAllBool = $false
switch -Regex ($IncludeAll) {
  '^(?i:true|1|yes)$'  { $IncludeAllBool = $true;  break }
  '^(?i:false|0|no)$'  { $IncludeAllBool = $false; break }
  default { throw "IncludeAll must be true/false/1/0/yes/no, got '$IncludeAll'" }
}

if (-not (Test-Path -LiteralPath $FilesList)) {
  throw "FilesList not found: $FilesList"
}

# 제외 패턴 처리
$excludePatterns = @()
if ($Exclude) {
  $excludePatterns = $Exclude -split ';' | ForEach-Object { $_.Trim() } | Where-Object { $_ }
}
function Is-Excluded([string]$ns) {
  foreach ($p in $excludePatterns) {
    if ($ns -eq $p) { return $true }
    if ($p.EndsWith('.*')) {
      $prefix = $p.Substring(0, $p.Length - 2)
      if ($ns.StartsWith($prefix, [System.StringComparison]::Ordinal)) { return $true }
    }
  }
  return $false
}

# 정규식
$rxNs        = [regex] '\bnamespace\s+([A-Za-z_][\w\.]*)\s*(?:;|\{)'
$rxAnyPublic = [regex] '\bpublic\s+(class|struct|interface|enum)\b'
$rxXamlBase  = [regex] 'public\s+(?:sealed\s+|abstract\s+)?class\s+\w+\s*:\s*([^{}\r\n]+)'

# 네임스페이스 집합
$nsSet = New-Object 'System.Collections.Generic.HashSet[string]' ([System.StringComparer]::Ordinal)

Get-Content -LiteralPath $FilesList | ForEach-Object {
  $path = $_.Trim()
  if (-not $path) { return }
  if (-not (Test-Path -LiteralPath $path)) { return }

  $text = [System.IO.File]::ReadAllText($path)

  # 파일 포함 여부
  $includeThisFile = $false
  if ($IncludeAllBool) {
    $includeThisFile = $rxAnyPublic.IsMatch($text)
  } else {
    foreach ($m in $rxXamlBase.Matches($text)) {
      $bases = $m.Groups[1].Value
      if ($bases -match '\b(System\.Windows\.)?DependencyObject\b' -or
          $bases -match '\b(System\.Windows\.Markup\.)?MarkupExtension\b') {
        $includeThisFile = $true; break
      }
    }
  }
  if (-not $includeThisFile) { return }

  foreach ($m in $rxNs.Matches($text)) {
    $ns = $m.Groups[1].Value
    if ([string]::IsNullOrWhiteSpace($ns)) { continue }
    if (Is-Excluded $ns) { continue }
    $null = $nsSet.Add($ns)
  }
}

# 생성
$dir = [System.IO.Path]::GetDirectoryName($OutputFile)
if ($dir -and -not (Test-Path -LiteralPath $dir)) { [System.IO.Directory]::CreateDirectory($dir) | Out-Null }

$sb = New-Object System.Text.StringBuilder
$null = $sb.AppendLine('// <auto-generated/>')
$null = $sb.AppendLine('using System.Windows.Markup;')
$null = $sb.AppendLine("[assembly: XmlnsPrefix(`"$Url`", `"$Prefix`")]")

# 🔧 ToArray() 대신 배열 강제화 + 정렬
$nsList = @($nsSet)                            # HashSet → object[] 로 물리화
[Array]::Sort([Array]$nsList, [System.StringComparer]::Ordinal)  # Ordinal 정렬

foreach ($ns in $nsList) {
  $null = $sb.AppendLine("[assembly: XmlnsDefinition(`"$Url`", `"$ns`")]")
}

$utf8NoBom = New-Object System.Text.UTF8Encoding($false)
[System.IO.File]::WriteAllText($OutputFile, $sb.ToString(), $utf8NoBom)
