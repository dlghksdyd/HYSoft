# scripts/Generate-GlobalXmlns.ps1
[CmdletBinding()]
param(
  [Parameter(Mandatory=$true)][string]$Url,
  [Parameter(Mandatory=$true)][string]$Prefix,
  # ë¬¸ìì—´ë¡œ ë°›ê³  ì§ì ‘ íŒŒì‹± (true/false/1/0/yes/no)
  [Parameter(Mandatory=$true)][string]$IncludeAll,
  [Parameter()][string]$Exclude,
  # í•œ ì¤„ë‹¹ í•˜ë‚˜ì˜ íŒŒì¼ ì „ì²´ ê²½ë¡œ
  [Parameter(Mandatory=$true)][string]$FilesList,
  [Parameter(Mandatory=$true)][string]$OutputFile
)

# ë¬¸ìì—´ â†’ bool
$IncludeAllBool = $false
switch -Regex ($IncludeAll) {
  '^(?i:true|1|yes)$'  { $IncludeAllBool = $true;  break }
  '^(?i:false|0|no)$'  { $IncludeAllBool = $false; break }
  default { throw "IncludeAll must be true/false/1/0/yes/no, got '$IncludeAll'" }
}

if (-not (Test-Path -LiteralPath $FilesList)) {
  throw "FilesList not found: $FilesList"
}

# ì œì™¸ íŒ¨í„´ ì²˜ë¦¬
$excludePatterns = @()
if ($Exclude) {
  $excludePatterns = $Exclude -split ';' | ForEach-Object { $_.Trim() } | Where-Object { $_ }
}
function Is-Excluded([string]$ns) {
  foreach ($p in $excludePatterns) {
    if ($ns -eq $p) { return $true }
    if ($p.EndsWith('.*')) {
      $prefix = $p.Substring(0, $p.Length - 2)
      if ($ns.StartsWith($prefix, [System.StringComparison]::Ordinal)) { return $true }
    }
  }
  return $false
}

# ì •ê·œì‹
$rxNs        = [regex] '\bnamespace\s+([A-Za-z_][\w\.]*)\s*(?:;|\{)'
$rxAnyPublic = [regex] '\bpublic\s+(class|struct|interface|enum)\b'
$rxXamlBase  = [regex] 'public\s+(?:sealed\s+|abstract\s+)?class\s+\w+\s*:\s*([^{}\r\n]+)'

# ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì§‘í•©
$nsSet = New-Object 'System.Collections.Generic.HashSet[string]' ([System.StringComparer]::Ordinal)

Get-Content -LiteralPath $FilesList | ForEach-Object {
  $path = $_.Trim()
  if (-not $path) { return }
  if (-not (Test-Path -LiteralPath $path)) { return }

  $text = [System.IO.File]::ReadAllText($path)

  # íŒŒì¼ í¬í•¨ ì—¬ë¶€
  $includeThisFile = $false
  if ($IncludeAllBool) {
    $includeThisFile = $rxAnyPublic.IsMatch($text)
  } else {
    foreach ($m in $rxXamlBase.Matches($text)) {
      $bases = $m.Groups[1].Value
      if ($bases -match '\b(System\.Windows\.)?DependencyObject\b' -or
          $bases -match '\b(System\.Windows\.Markup\.)?MarkupExtension\b') {
        $includeThisFile = $true; break
      }
    }
  }
  if (-not $includeThisFile) { return }

  foreach ($m in $rxNs.Matches($text)) {
    $ns = $m.Groups[1].Value
    if ([string]::IsNullOrWhiteSpace($ns)) { continue }
    if (Is-Excluded $ns) { continue }
    $null = $nsSet.Add($ns)
  }
}

# ìƒì„±
$dir = [System.IO.Path]::GetDirectoryName($OutputFile)
if ($dir -and -not (Test-Path -LiteralPath $dir)) { [System.IO.Directory]::CreateDirectory($dir) | Out-Null }

$sb = New-Object System.Text.StringBuilder
$null = $sb.AppendLine('// <auto-generated/>')
$null = $sb.AppendLine('using System.Windows.Markup;')
$null = $sb.AppendLine("[assembly: XmlnsPrefix(`"$Url`", `"$Prefix`")]")

# ğŸ”§ ToArray() ëŒ€ì‹  ë°°ì—´ ê°•ì œí™” + ì •ë ¬
$nsList = @($nsSet)                            # HashSet â†’ object[] ë¡œ ë¬¼ë¦¬í™”
[Array]::Sort([Array]$nsList, [System.StringComparer]::Ordinal)  # Ordinal ì •ë ¬

foreach ($ns in $nsList) {
  $null = $sb.AppendLine("[assembly: XmlnsDefinition(`"$Url`", `"$ns`")]")
}

$utf8NoBom = New-Object System.Text.UTF8Encoding($false)
[System.IO.File]::WriteAllText($OutputFile, $sb.ToString(), $utf8NoBom)
